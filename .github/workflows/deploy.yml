name: Deploy Java Application to AWS

on:
  push:
    branches:
      - main
      - master
  pull_request:
    branches:
      - main
      - master
  workflow_dispatch:

env:
  AWS_REGION: ap-south-1
  ECR_REPOSITORY: java-app-repo
  DOCKER_IMAGE_TAG: ${{ github.sha }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK 11
      uses: actions/setup-java@v4
      with:
        java-version: '11'
        distribution: 'adopt'
        
    - name: Cache Maven dependencies
      uses: actions/cache@v3
      with:
        path: ~/.m2
        key: ${{ runner.os }}-m2-${{ hashFiles('**/pom.xml') }}
        restore-keys: ${{ runner.os }}-m2
        
    - name: Run tests
      run: |
        if [ -f "pom.xml" ]; then
          mvn clean test
        elif [ -f "build.gradle" ]; then
          ./gradlew test
        else
          echo "No test configuration found, skipping tests"
        fi

  build:
    needs: test
    runs-on: ubuntu-latest
    
    outputs:
      image-uri: ${{ steps.build-image.outputs.image }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK 11
      uses: actions/setup-java@v4
      with:
        java-version: '11'
        distribution: 'adopt'
        
    - name: Build application
      run: |
        if [ -f "pom.xml" ]; then
          mvn clean package -DskipTests
        elif [ -f "build.gradle" ]; then
          ./gradlew build -x test
        else
          echo "Creating test JAR file..."
          mkdir -p build/libs src/main/java/com/test
          
          cat > src/main/java/com/test/TestServer.java << 'EOF'
        package com.test;
        
        import com.sun.net.httpserver.HttpServer;
        import com.sun.net.httpserver.HttpHandler;
        import com.sun.net.httpserver.HttpExchange;
        import java.io.*;
        import java.net.InetSocketAddress;
        
        public class TestServer {
            public static void main(String[] args) throws Exception {
                HttpServer server = HttpServer.create(new InetSocketAddress(9000), 0);
                
                server.createContext("/", new HttpHandler() {
                    @Override
                    public void handle(HttpExchange exchange) throws IOException {
                        String response = "Hello from Java Test Server! Time: " + new java.util.Date();
                        exchange.sendResponseHeaders(200, response.length());
                        OutputStream os = exchange.getResponseBody();
                        os.write(response.getBytes());
                        os.close();
                    }
                });
                
                server.createContext("/health", new HttpHandler() {
                    @Override
                    public void handle(HttpExchange exchange) throws IOException {
                        String response = "{\"status\":\"healthy\",\"timestamp\":\"" + new java.util.Date() + "\"}";
                        exchange.getResponseHeaders().set("Content-Type", "application/json");
                        exchange.sendResponseHeaders(200, response.length());
                        OutputStream os = exchange.getResponseBody();
                        os.write(response.getBytes());
                        os.close();
                    }
                });
                
                server.setExecutor(null);
                System.out.println("Server starting on port 9000...");
                server.start();
                System.out.println("Server started successfully on http://localhost:9000");
            }
        }
        EOF
          
          javac -d build/classes src/main/java/com/test/TestServer.java
          cd build/classes
          jar cfe ../libs/project.jar com.test.TestServer com/test/TestServer.class
          cd ../..
        fi
        
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
      
    - name: Create ECR repository if it doesn't exist
      run: |
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
        
    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        # Build Docker image
        docker build -f docker/Dockerfile -t $ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_IMAGE_TAG .
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # Push image to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$DOCKER_IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Deploy to EC2
      env:
        DOCKER_IMAGE_URI: ${{ needs.build.outputs.image-uri }}
      run: |
        # Find running EC2 instances with the app tag
        INSTANCE_IDS=$(aws ec2 describe-instances \
          --filters "Name=tag:Name,Values=java-app" "Name=instance-state-name,Values=running" \
          --query 'Reservations[].Instances[].InstanceId' \
          --output text \
          --region $AWS_REGION)
        
        if [ -z "$INSTANCE_IDS" ]; then
          echo "No running EC2 instances found. Creating new instance..."
          
          # Create new EC2 instance
          INSTANCE_ID=$(aws ec2 run-instances \
            --image-id ami-0c02fb55956c7d316 \
            --count 1 \
            --instance-type t3.micro \
            --key-name ${{ secrets.EC2_KEY_PAIR_NAME }} \
            --security-group-ids ${{ secrets.SECURITY_GROUP_ID }} \
            --subnet-id ${{ secrets.SUBNET_ID_1 }} \
            --tag-specifications 'ResourceType=instance,Tags=[{Key=Name,Value=java-app},{Key=Environment,Value=production}]' \
            --query 'Instances[0].InstanceId' \
            --output text \
            --region $AWS_REGION)
          
          echo "Created new instance: $INSTANCE_ID"
          
          # Wait for instance to be running
          aws ec2 wait instance-running --instance-ids $INSTANCE_ID --region $AWS_REGION
          
          INSTANCE_IDS=$INSTANCE_ID
        fi
        
        # Update each instance
        for INSTANCE_ID in $INSTANCE_IDS; do
          echo "Updating instance: $INSTANCE_ID"
          
          # Get instance public IP
          PUBLIC_IP=$(aws ec2 describe-instances \
            --instance-ids $INSTANCE_ID \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text \
            --region $AWS_REGION)
          
          echo "Instance public IP: $PUBLIC_IP"
          
          # Update the application on the instance
          aws ssm send-command \
            --instance-ids $INSTANCE_ID \
            --document-name "AWS-RunShellScript" \
            --parameters 'commands=[
              "docker stop java-app || true",
              "docker rm java-app || true",
              "docker pull '$DOCKER_IMAGE_URI'",
              "docker run -d --name java-app -p 9000:9000 --restart unless-stopped '$DOCKER_IMAGE_URI'",
              "sleep 10",
              "curl -f http://localhost:9000/ || exit 1"
            ]' \
            --region $AWS_REGION \
            --output text || echo "SSM not available, deployment via SSH required"
        done
        
    - name: Update Load Balancer
      run: |
        # Ensure load balancer exists and targets are registered
        ALB_ARN=$(aws elbv2 describe-load-balancers \
          --names java-app-alb \
          --query 'LoadBalancers[0].LoadBalancerArn' \
          --output text \
          --region $AWS_REGION 2>/dev/null || echo "None")
        
        if [ "$ALB_ARN" = "None" ]; then
          echo "Load balancer not found. Run the create-elb.sh script manually."
        else
          echo "Load balancer exists: $ALB_ARN"
          
          # Get target group ARN
          TG_ARN=$(aws elbv2 describe-target-groups \
            --names java-app-targets \
            --query 'TargetGroups[0].TargetGroupArn' \
            --output text \
            --region $AWS_REGION)
          
          # Register new instances with target group
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=java-app" "Name=instance-state-name,Values=running" \
            --query 'Reservations[].Instances[].InstanceId' \
            --output text \
            --region $AWS_REGION)
          
          for INSTANCE_ID in $INSTANCE_IDS; do
            aws elbv2 register-targets \
              --target-group-arn $TG_ARN \
              --targets Id=$INSTANCE_ID,Port=9000 \
              --region $AWS_REGION || echo "Target already registered"
          done
        fi
        
    - name: Deployment Summary
      run: |
        echo "üöÄ Deployment completed successfully!"
        echo "üì¶ Docker image: ${{ needs.build.outputs.image-uri }}"
        echo "üåç Region: $AWS_REGION"
        echo "üìù Check AWS console for detailed status"
        
        # Get load balancer URL if available
        ALB_DNS=$(aws elbv2 describe-load-balancers \
          --names java-app-alb \
          --query 'LoadBalancers[0].DNSName' \
          --output text \
          --region $AWS_REGION 2>/dev/null || echo "Not found")
        
        if [ "$ALB_DNS" != "Not found" ]; then
          echo "üåê Application URL: http://$ALB_DNS"
        fi
